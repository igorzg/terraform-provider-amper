diff --git a/filter_tpl.go b/filter_tpl.go
index e2ab12a..5785e1c 100644
--- a/filter_tpl.go
+++ b/filter_tpl.go
@@ -4,11 +4,16 @@ import (
 	"bytes"
 	"fmt"
 	"github.com/Masterminds/sprig"
+	"github.com/aws/aws-sdk-go/aws"
+	"github.com/aws/aws-sdk-go/aws/session"
+	"github.com/aws/aws-sdk-go/s3"
 	"io"
 	"io/ioutil"
 	"net"
+	"net/url"
 	"os"
 	"path/filepath"
+	"strings"
 	"text/template"
 )
 
@@ -16,6 +21,7 @@ type FilterTPL struct {
 	fc       *FC
 	funcMap  map[string]interface{}
 	basepath string
+	s3Conn   *s3.S3
 }
 
 func cidr_Contains(cidr_addr, ip_addr string) (r bool, err error) {
@@ -113,6 +119,133 @@ func (f FilterTPL) importTpl(filename string) (_ interface{}, err error) {
 	}, nil
 }
 
+func (f *FilterTPL) getS3Connection() (*s3.S3, error) {
+	if f.s3Conn {
+		return f.s3Conn, nil
+	}
+
+	sess, err := session.NewSession()
+
+	if err != nil {
+		return nil, err
+	}
+
+	f.s3Conn, err = s3.New(sess)
+
+	if err != nil {
+		return nil, err
+	}
+
+	return f.s3Conn, nil
+}
+
+func (f *FilterTPL) load(urlStr string, args ...interface{}) (string, error) {
+	loadUrl, err := url.Parse(urlStr)
+
+	if err != nil {
+		return "", err
+	}
+
+	if loadUrl.Scheme == "file" {
+
+	} else if loadUrl.Scheme == "s3" {
+		parts := strings.SplitN(loadUrl.Path, ":", 2)
+
+		versionId * string
+
+		if len(parts) > 1 {
+			version = aws.String(parts[1])
+		}
+
+		res, err := s3.GetObject(&s3.GetObjectInput{
+			Bucket:    aws.String(loadUrl.Host),
+			Key:       aws.String(parts[0]),
+			VersionId: versionId,
+		})
+
+		if err != nil {
+			return nil, err
+		}
+	} else {
+		return "", fmt.Errorf("Unknown url scheme '%s'", loadUrl.Scheme)
+	}
+}
+
+func (f *FilterTPL) s3GetObjects(bucket, prefix, pattern string) (result []string, err error) {
+	s3Conn, err := f.getS3Connection()
+	
+	downloader := make(chan *s3.GetObjectInput, 16)
+
+	
+
+	if err != nil {
+		return nil, err
+	}
+
+	input := &s3.ListObjectsV2Input{
+		Bucket: aws.String(bucket),
+		Prefix: aws.String(prefix),
+	}
+
+	for {
+		res, err := s3Conn.ListObjectsV2(input)
+
+		if err != nil {
+			return nil, err
+		}
+
+		for _, elem := range res.Contents {
+			key := *elem.Key
+			match, err := filepath.Match(pattern, key)
+
+			if err != nil {
+				return nil, err
+			}
+
+			if match {
+				
+				result = append(result, key)
+			}
+		}
+
+		if *res.IsTruncated && res.NextContinuationToken != nil {
+			input.SetContinuationToken(*res.NextContinuationToken)
+		} else {
+			break
+		}
+	}
+
+	return result, nil
+}
+
+
+
+func (f *FilterTPL) loadS3Wildcard(urlStr string, fileinfo map[string]interface{}) ([]interface{}, error) {
+	loadUrl, err := url.Parse(urlStr)
+
+	if loadUrl.Scheme == "s3" {
+		if strings.Count(loadUrl.Path, "*") != 1 {
+			return nil, fmt.Errorf("Pattern can contain exactly one '*'")
+		}
+
+		wcParts = strings.Split(loadUrl.Path, "*")
+
+		s3Conn, err := f.getS3Connection()
+
+		if err != nil {
+			return nil, err
+		}
+
+		files, err := f.s3ListObjects(loadUrl.Host, wcParts[0], loadUrl.Path)
+
+		if err != nil {
+			return nil, err
+		}
+
+		
+	}
+}
+
 func NewFilterTPL() (r *FilterTPL) {
 	r = &FilterTPL{}
 
@@ -131,6 +264,8 @@ func NewFilterTPL() (r *FilterTPL) {
 		return TplImport{tpl: tpl}.Render(ctx)
 	}
 
+	r.funcMap["load"]
+
 	r.basepath = os.Getenv("FC_TPL_BASEPATH")
 
 	return
